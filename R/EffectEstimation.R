#' Absolute risk reduction
#'
#' Calculates absolute risk reduction based on the Kaplan-Meier estimates within risk strata
#'
#' @param population         The study population generated by \code{\link[CohortMethod]{matchOnPs}} when using propensity score
#'                           matching or by \code{\link[CohortMethod]{stratifyByPs}} when stratifying on the propensity score. In
#'                           case of inverse probability of treatment weighting approach, it is a datframe with a \code{weights}
#'                           column.
#' @param timePoint          The time at which the absolute risk difference is estimated
#' @param psMethod           Can be one of "matchOnPs", "stratifyByPs" or "inversePtWeighted".
#'
#' @return                   A dataframe with the absolute risk-stratum specific absolute risk difference estimates, along
#'                           with 95 percent confidence interval.
#'
#' @export

absoluteRiskReduction <- function(population,
                                  timePoint,
                                  psMethod){

  population <- as.data.frame(population)
  population$event <- ifelse(is.na(population$daysToEvent), 0, 1)
  population$S <- survival::Surv(population$survivalTime, population$event)

  kaplanMeier <-  survival::survfit(S ~ treatment, data = population)

  if(psMethod == "matchOnPs"){

    summaryKM <- summary(kaplanMeier, times = timePoint)
    standardError <- sqrt(sum(summaryKM$std.err^2))
    arr <- diff(summaryKM$surv)
    res <- c(arr, arr - 1.96*standardError, arr + 1.96*standardError)

  }
  else if(psMethod == "stratifyByPS"){

    kaplanMeier <- list()
    kk <- sort(unique(population$stratumId))
    for(i in kk){
      kaplanMeier[[i]] <- survival::survfit(S ~ treatment, data = subset(population, stratumId == i))
    }

    summaryKMList <- lapply(kaplanMeier, summary, times = timePoint)
    arrList <- lapply(summaryKMList, getAbsoluteDifference)

    arr <- mean(unlist(arrList))
    standardErrors <- lapply(summaryKMList, getStandadrdError)
    pooledStandardError <- sqrt(sum(unlist(standardErrors)^2)/25)
    res <- c(arr, arr - 1.96*pooledStandardError, arr + 1.96*pooledStandardError)

  }

  else if(psMethod == "inversePtWeighted"){

    kaplanMeier <-  survival::survfit(S ~ treatment, data = population, weights = weights)
    summaryKM <- summary(kaplanMeier, times = timePoint)
    standardError <- sqrt(sum(summaryKM$std.err^2))
    arr <- diff(summaryKM$surv)
    res <- c(arr, arr - 1.96*standardError, arr + 1.96*standardError)

  }

  return(res)

}




#' Relative risk reduction
#'
#' Calculates hazard ratios within risk strata.
#' @param model    The model that was used to fit a cox regression model to the data.
#'
#' @return         A dataframe with hazard ratios for treatment effect across risk strata along with 95 percent confidence intervals
#'
#' @export

relativeRiskReduction <- function(model){

  if(class(model) == "outcomeModel")
    return(exp(model$outcomeModelTreatmentEstimate[1:3]))
  else
    return(summary(model)$conf.int[c(1, 3:4)])

}




#' Fits a weighted cox regression model
#'
#' Fits a weighted cox regression model using an inverse probability of treatment weighting approach
#'
#' @param ps                          A dataframe wiht propensity scores as generated from \code{\link[CohortMethod]{createPs}}.
#' @param calculateWeights            Should weights be calculated?
#' @param weightsType                 The type of weights for the balancing of covariates. Should be either 'ATE' or 'ATT'
#' @param useStabilizedWeights        Should stabilized weights be used?
#' @param truncationLevels            The level of truncation expressed in percentiles of the propensity score.
#'
#' @return                            A weighted cox regression model.
#'
#' @export

outcomeModelWeighted <- function(ps,
                                 calculateWeights = TRUE,
                                 weightsType = 'ATE',
                                 useStabilizedWeights = TRUE,
                                 truncationLevels){

  if(calculateWeights)
    ps <- createIPW(ps,
                    weightsType = weightsType,
                    useStabilizedWeights = useStabilizedWeights,
                    truncationLevels = truncationLevels)



  ps$outcomeCount <- ifelse(ps$outcomeCount != 0, 1, 0)
  model <- survival::coxph(survival::Surv(survivalTime, outcomeCount) ~ treatment,
                           data = ps,
                           weights = ps$weights, robust = TRUE)
  return(model)

}



#' Creates Inverse Probability Weights
#'
#' Calcuates inverse probability weights based on the propensity score
#'
#' @param ps A propensity score data frame as created from \code{\link[CohortMethod]{createPs}}
#' @param weightsType The type of the weights to be used. Allowed options are 'ATE' for average treatment effect and 'ATT' for average treatment effect on the treated weights
#' @param useStabilizedWeights Should stabilized weights be used?
#' @param truncationLevels The level of truncation expressed in percentiles of the propensity score.
#'
#' @return The ps data frame provided as input along with a weights column
#'
#' @export

createIPW <- function(ps,
                      weightsType = 'ATE',
                      useStabilizedWeights = TRUE,
                      truncationLevels = c(.01, .99)){

  if(weightsType == 'ATE')
    ps$weights <- ps$treatment / ps$propensityScore + (1 - ps$treatment) / (1 - ps$propensityScore)
  else
    ps$weights <- ps$treatment + ps$propensityScore*(1 - ps$treatment) / (1 - ps$propensityScore)

  if(useStabilizedWeights){
    ps$stability <- mean(ps$treatment)
    ps$weights <- ps$treatment*ps$weights*ps$stability +
      (1 - ps$treatment)*ps$weights*(1 - ps$stability)
    ps <- dplyr::select(ps, -stability)
  }

  ps <-  dplyr::mutate(ps, weights = pmin(pmax(weights, quantile(weights, truncationLevels[1])),
                                          quantile(weights, truncationLevels[2])))


  return(ps)

}



#' Calculates the weighted Kaplan-Meier estimates
#'
#' Calculates the weighted Kaplan-Meier estimates.
#'
#' @param ps A data frame including the propensity scores as generated from \code{\link[CohortMethod]{createPs}}
#' @param calculateWeights Whether to calculate the weights using \code{\link[RiskStratifiedEstimation]{createIPW}}
#' @param weightsType The type of the weights to be used. Allowed options are 'ATE' for average treatment effect and 'ATT' for average treatment effect on the treated weights
#' @param useStabilizedWeights Should stabilized weights be used?
#' @param truncationLevels The level of truncation expressed in percentiles of the propensity score.
#'
#' @return A data frame with the Kaplan-Meier estimates
#'
#' @references Xie J, Liu C. Adjusted Kaplan-Meier estimator and log-rank test with inverse probability of treatment weighting for survival data. Statistics in Medicine 2005; 2:3089â€“3110.
#'
#' @export

weightedKM <- function(ps,
                       calculateWeights = TRUE,
                       weightsType = 'ATE',
                       useStabilizedWeights = TRUE,
                       truncationLevels){

  if(calculateWeights)
    ps <- createIPW(ps,
                    weightsType = weightsType,
                    useStabilizedWeights = useStabilizedWeights,
                    truncationLevels = truncationLevels)

  ps <- subset(ps, select = c('subjectId', 'treatment', 'outcomeCount', 'daysToEvent', 'survivalTime', 'weights'))
  ps$failure <- ifelse(is.na(ps$daysToEvent), 0, 1)
  ps$outcomeCount <- ifelse(ps$outcomeCount>0, 1, 0)

  psTreatment <- subset(ps, treatment == 1)
  psTreatment <- dplyr::arrange(psTreatment, survivalTime)
  p1 <- length(psTreatment$weights)

  psComparator <- subset(ps, treatment == 0)
  psComparator <- dplyr::arrange(psComparator, survivalTime)
  p0 <- length(psComparator$weights)
  s <- 1
  S <- 1
  V <- 0
  dataTreatment <- data.frame(time = numeric(),
                              S = numeric(),
                              varS = numeric(),
                              lower = numeric(),
                              upper = numeric(),
                              eventTime = numeric())

  for(i in unique(psTreatment$survivalTime)){

    j <- which(psTreatment$survivalTime == i)
    v <- sum(psTreatment$failure[j]*psTreatment$weights[j])
    eventTime <- ifelse(v>0, 1, 0)
    y <- tail(cumsum(psTreatment$weights[min(j):p1]), n = 1)
    M <- y^2/tail(cumsum(psTreatment$weights[min(j):p1]^2), n = 1)
    s_j <- 1 - v/y
    V <- V + (1 - s_j)/M/s_j
    S <- S*s_j
    varS <- S^2*V
    lower = exp(-exp(log(-log(S)) - 1.96*sqrt(V)/log(S)))
    upper = exp(-exp(log(-log(S)) + 1.96*sqrt(V)/log(S)))
    dataTreatment[s, ] <- c(i, S, varS, lower, upper, eventTime)
    s <- s + 1

  }

  s <- 1
  S <- 1
  V <- 0
  dataComparator <- data.frame(time = numeric(),
                               S = numeric(),
                               varS = numeric(),
                               lower = numeric(),
                               upper = numeric(),
                               eventTime = numeric())

  for(i in unique(psComparator$survivalTime)){

    j <- which(psComparator$survivalTime == i)
    v <- sum(psComparator$failure[j]*psComparator$weights[j])
    eventTime <- ifelse(v>0, 1, 0)
    y <- tail(cumsum(psComparator$weights[min(j):p0]), n = 1)
    M <- y^2/tail(cumsum(psComparator$weights[min(j):p0]^2), n = 1)
    s_j <- 1 - v/y
    V <- V + (1 - s_j)/M/s_j
    S <- S*s_j
    varS <- S^2*V
    lower = exp(-exp(log(-log(S)) - 1.96*sqrt(V)/log(S)))
    upper = exp(-exp(log(-log(S)) + 1.96*sqrt(V)/log(S)))
    dataComparator[s, ] <-c(i, S, varS, lower, upper, eventTime)
    s <- s + 1

  }

  dataCombined <- dplyr::bind_rows(list(treatment=dataTreatment,
                                        comparator = dataComparator),
                                   .id = 'cohort')


  return(dataCombined)
}



#' Calculate stratified Kaplan-Meier estimates
#'
#' @param population                The population of interest stratified using the  \code{\link[CohortMethod]{stratifyByPs}}
#' @param timePoint                 The point in time for which the absolute risk difference is required
#'
#' @return                          A vector of the absolute risk difference along with the lowest and highest limits of the
#'                                  the 95 percent confidence interval
#'
stratifiedKaplanMeier <- function(population, timePoint){
  kaplanMeier <- list()
  for(i in unique(population$stratumId)){
    kaplanMeier[[i]] <- survival::survfit(S ~ treatment, data = subset(population, stratumId == i))
  }

  summaryKMList <- lapply(kaplanMeier, summary, times = timePoint)
  arrList <- lapply(summaryKMList, getAbsoluteDifference)

  arr <- mean(unlist(arrList))
  standardErrors <- lapply(summaryKMList, getStandadrdError)
  pooledStandardError <- sqrt(sum(unlist(standardErrors)^2)/25)
  return(c(arr, arr - 1.96*pooledStandardError, arr + 1.96*pooledStandardError))

}




#' Calculate propensity scores for a specific outcome
#'
#' Fits a large-scale regularized regression model to estimate propensity scores within predicted risk strata. Designed
#' to be applied in a parallelized analysis.
#'
#' @param cohortMethodDataFolder               The directory where the \code{cohortMethodData} object is stored.
#' @param plpDataFolder                        The directory where the \code{plpData} object is stored.
#' @param outcomeId                            The outcome of interest for which the risk stratification is performed.
#' @param populationCmSettings                 A parameter object for the function \code{\link[CohortMethod]{createStudyPopulation}}.
#'                                             Can be generated from function \code{createStudyPopulationCmSettings}.
#' @param populationPlpSettings                A parameter object for the function \code{\link[PatientLevelPrediction]{createStudyPopulation}}.
#'                                             Can be generated from unction \code{\link[PatientLevelPrediction]{createStudyPopulationSettings}}.
#' @param saveDirectory                        The direcotry of the RSEE analysis where the prediction models are located.
#' @param riskStrata                           The considered number of risk strata.
#' @param analysisId                           The analysis ID of the prediction model used to stratify the population.
#' @param analysisPath                         The directory where the propensity scores will be stored.
#'
#' @return                                     \code{NULL}. The results are all saved.
#'
#' @export

fitPsModel <- function(cohortMethodDataFolder,
                       plpDataFolder,
                       outcomeId,
                       populationCmSettings,
                       populationPlpSettings,
                       saveDirectory,
                       riskStrata,
                       analysisId,
                       analysisPath){

  cohortMethodData <- CohortMethod::loadCohortMethodData(file = cohortMethodDataFolder)
  plpData <- PatientLevelPrediction::loadPlpData(file = plpDataFolder)


  populationPlp <-
    PatientLevelPrediction::createStudyPopulation(plpData = plpData,
                                                  outcomeId = outcomeId,
                                                  binary = populationPlpSettings$binary,
                                                  includeAllOutcomes = populationPlpSettings$includeAllOutcomes,
                                                  firstExposureOnly = populationPlpSettings$firstExposureOnly,
                                                  washoutPeriod = populationPlpSettings$washoutPeriod,
                                                  removeSubjectsWithPriorOutcome = populationPlpSettings$removeSubjectsWithPriorOutcome,
                                                  priorOutcomeLookback = populationPlpSettings$priorOutcomeLookback,
                                                  requireTimeAtRisk = populationPlpSettings$requireTimeAtRisk,
                                                  minTimeAtRisk = populationPlpSettings$minTimeAtRisk,
                                                  riskWindowStart = populationPlpSettings$riskWindowStart,
                                                  addExposureDaysToStart = populationPlpSettings$addExposureDaysToStart,
                                                  riskWindowEnd = populationPlpSettings$riskWindowEnd,
                                                  addExposureDaysToEnd = populationPlpSettings$addExposureDaysToEnd,
                                                  verbosity = populationPlpSettings$verbosity)
  populationCm <-
    CohortMethod::createStudyPopulation(cohortMethodData = cohortMethodData,
                                        outcomeId = outcomeId,
                                        firstExposureOnly = populationCmSettings$firstExposureOnly,
                                        restrictToCommonPeriod = populationCmSettings$restrictToCommonPeriod,
                                        washoutPeriod = populationCmSettings$washoutPeriod,
                                        removeDuplicateSubjects = populationCmSettings$removeDuplicateSubjects,
                                        removeSubjectsWithPriorOutcome = populationCmSettings$removeSubjectsWithPriorOutcome,
                                        priorOutcomeLookback = populationCmSettings$priorOutcomeLookback,
                                        minDaysAtRisk = populationCmSettings$minDaysAtRisk,
                                        riskWindowStart = populationCmSettings$riskWindowStart,
                                        addExposureDaysToStart = populationCmSettings$addExposureDaysToStart,
                                        riskWindowEnd = populationCmSettings$riskWindowEnd,
                                        addExposureDaysToEnd = populationCmSettings$addExposureDaysToEnd,
                                        censorAtNewRiskWindow = populationCmSettings$censorAtNewRiskWindow)

  populationCmMetaData <- attr(populationCm, "metaData")
  attr(populationCm, "metaData") <- attr(populationPlp, "metaData")

  predictionResult <-
    PatientLevelPrediction::loadPlpResult(file.path(saveDirectory, "Prediction", outcomeId, analysisId, "plpResult"))

  riskPredictions <- predictionResult$model$predict(plpData = plpData,
                                                    population = populationCm)
  riskPredictions <- subset(riskPredictions,
                            select = c(rowId, subjectId, value))

  attr(populationCm, "metaData") <- populationCmMetaData
  ParallelLogger::logInfo("Stratifying estimation population")
  mapMatrix <- riskPredictions
  mapMatrix <- dplyr::mutate(mapMatrix, riskStratum = dplyr::ntile(riskPredictions$value,
                                                                   riskStrata))

  psControl <-  Cyclops::createControl(threads = 1, maxIterations = 1e4)
  psPrior <- Cyclops::createPrior(priorType = "laplace",
                                  exclude = c(0),
                                  useCrossValidation = TRUE)
  ps <- list()
  for(i in 1:riskStrata){
    population <- populationCm[populationCm$subjectId %in% mapMatrix[mapMatrix$riskStratum == i,]$subjectId, ]
    ps[[i]] <- CohortMethod::createPs(cohortMethodData = cohortMethodData,
                                      population = population,
                                      stopOnError = FALSE,
                                      errorOnHighCorrelation = FALSE,
                                      control = psControl,
                                      prior = psPrior)
  }


  saveDir <- file.path(analysisPath, "Estimation", outcomeId)
  dir.create(saveDir, recursive = TRUE)
  saveRDS(lapply(ps, as.data.frame),
          file.path(saveDir, "ps.rds"))


  saveRDS(mapMatrix, file.path(analysisPath, "Estimation", outcomeId, 'mapMatrix.rds'))
  ParallelLogger::logInfo(paste("Saved the map matrix for outcome", outcomeId))

  return(NULL)
}





#' Fit outcome models
#'
#' Fits outcome models within risk strata, estimating relative and absolute differences. Designed to be performed within
#' a parellelized analysis.
#'
#' @param outcomeId               The outcome of interest for which the esitmation is performed. That is the outcome for which risk stratification is performed.
#' @param analysisPath            The path to the \code{RSEE} analysis results.
#' @param cohortMethodDataFolder  The directory where the \code{cohortMethodData} object is stored.
#' @param outcomeIdList           The other outcomes for which risk stratified estimates need to derived. Only required \code{compareAllOutcomes} is \code{TRUE}.
#' @param compareAllOutcomes      Compare all the outcomes within the \code{outcomeIdList} within risk strata of code{outcomeId}?
#' @param timePoint               The time point at which absolute risk differences will be calculated.
#' @param psMethod                Select the propensity score method for the estimation of treatment effects within risk strata. It can be "matchOnPs",
#'                                "stratifyByPs" or "inversePtWeighted".
#' @param weightsType             Only required if \code{weightsType} is "inversePtWeighted". The type of weights for the balancing of covariates.
#'                                Should be either 'ATE' or 'ATT'
#' @param useStabilizedWeights    Only required if \code{weightsType} is "inversePtWeighted". Should stabilized weights be used?
#' @param truncationLevels        Only required if \code{weightsType} is "inversePtWeighted". The level of truncation expressed in percentiles of the propensity score.
#' @param populationCmSettings    A parameter object for the function \code{\link[CohortMethod]{createStudyPopulation}}. Can be generated from
#'                                function \code{createStudyPopulationCmSettings}.
#'
#' @return                        \code{NULL}. The results are all saved.
#'
#' @export

fitOutcomeModels <- function(outcomeId,
                             analysisPath,
                             cohortMethodDataFolder,
                             outcomeIdList,
                             compareAllOutcomes,
                             timePoint,
                             psMethod,
                             weightsType,
                             useStabilizedWeights,
                             truncationLevels,
                             populationCmSettings){

  ParallelLogger::logInfo(paste("Calculating main results for outcome:", outcomeId))

  ps <- readRDS(file.path(analysisPath, "Estimation", outcomeId, "ps.rds"))
  cohortMethodData <- CohortMethod::loadCohortMethodData(file = cohortMethodDataFolder)

  cases <- do.call(rbind, lapply(ps, getCounts, timePoint = timePoint))
  colnames(cases) <- c("comparator", "treatment")
  cases <- as.data.frame(cases)
  riskStrata <- length(ps)
  cases$riskStratum <- paste0("Q", 1:riskStrata)

  if(psMethod == "matchOnPs"){

    matchedPop <- lapply(ps, CohortMethod::matchOnPs)
    models <- lapply(matchedPop,
                     CohortMethod::fitOutcomeModel, stratified = TRUE, modelType = "cox")
    arr <- do.call(rbind, lapply(matchedPop, absoluteRiskReduction, timePoint = timePoint, psMethod = psMethod))
    colnames(arr) <- c("ARR", "lower", "upper")
    arr <- as.data.frame(arr)
    arr$riskStratum <- paste0("Q", 1:riskStrata)
    rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
    colnames(rrr) <- c("HR", "lower", "upper")
    rrr <- as.data.frame(rrr)
    rrr$riskStratum <- paste0("Q", 1:riskStrata)

  }
  else if(psMethod == "stratifyByPs"){

    stratifiedPop <- lapply(ps, CohortMethod::stratifyByPs) # Add stratification settings
    models <- lapply(stratifiedPop,
                     CohortMethod::fitOutcomeModel, stratified = TRUE, modelType = "cox")
    arr <- do.call(rbind, lapply(stratifiedPop, absoluteRiskReduction, timePoint = timePoint, psMethod = "stratifyByPS"))
    colnames(arr) <- c("ARR", "lower", "upper")
    arr <- as.data.frame(arr)
    arr$riskStratum <- paste0("Q", 1:riskStrata)
    rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
    colnames(rrr) <- c("HR", "lower", "upper")
    rrr <- as.data.frame(rrr)
    rrr$riskStratum <- paste0("Q", 1:riskStrata)

  }
  else if(psMethod == "inversePtWeighted"){

    ps <- lapply(ps,
                 createIPW,
                 weightsType = weightsType,
                 useStabilizedWeights = useStabilizedWeights,
                 truncationLevels = truncationLevels)
    models <- lapply(ps, outcomeModelWeighted, calculateWeights = FALSE)
    arr <- do.call(rbind, lapply(ps, absoluteRiskReduction, timePoint = timePoint, psMethod = "inversePtWeighted"))
    colnames(arr) <- c("ARR", "lower", "upper")
    arr <- as.data.frame(arr)
    arr$riskStratum <- paste0("Q", 1:riskStrata)
    rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
    colnames(rrr) <- c("HR", "lower", "upper")
    rrr <- as.data.frame(rrr)
    rrr$riskStratum <- paste0("Q", 1:riskStrata)

  }

  saveDir <- paste(analysisPath, "Estimation", outcomeId, sep = "/")
  saveRDS(rrr, file = file.path(saveDir, 'relativeRiskReduction.rds'))
  saveRDS(arr, file = file.path(saveDir, 'absoluteRiskReduction.rds'))
  saveRDS(models, file = file.path(saveDir, 'models.rds'))
  saveRDS(cases, file = file.path(saveDir, 'cases.rds'))

  ParallelLogger::logInfo('Saved main the results')

  ParallelLogger::logInfo('Generating results for the other outcomes')

  if(compareAllOutcomes){

    numberOfComparisons <- length(outcomeIdList) - 1
    comparisonOutcomes <- outcomeIdList[outcomeIdList!=outcomeId]
    resSwitched <- list()
    modelsSwitched <- list()
    kaplanMeierSwitched <- list()
    rseeSwitched <- list()

    for(j in 1:numberOfComparisons){

      ParallelLogger::logInfo(paste("Stratification outcome", outcomeId, "results outcome:", comparisonOutcomes[j]))
      ParallelLogger::logInfo("Generating population with switched outcome")

      populationCm <-
        CohortMethod::createStudyPopulation(cohortMethodData = cohortMethodData,
                                            outcomeId = comparisonOutcomes[j],
                                            firstExposureOnly = populationCmSettings$firstExposureOnly,
                                            restrictToCommonPeriod = populationCmSettings$restrictToCommonPeriod,
                                            washoutPeriod = populationCmSettings$washoutPeriod,
                                            removeDuplicateSubjects = TRUE, # needs to be TRUE otherwise there is an error
                                            removeSubjectsWithPriorOutcome = populationCmSettings$removeSubjectsWithPriorOutcome,
                                            priorOutcomeLookback = populationCmSettings$priorOutcomeLookback,
                                            minDaysAtRisk = populationCmSettings$minDaysAtRisk,
                                            riskWindowStart = populationCmSettings$riskWindowStart,
                                            addExposureDaysToStart = populationCmSettings$addExposureDaysToStart,
                                            riskWindowEnd = populationCmSettings$riskWindowEnd,
                                            addExposureDaysToEnd = populationCmSettings$addExposureDaysToEnd,
                                            censorAtNewRiskWindow = populationCmSettings$censorAtNewRiskWindow)

      psSwitchedOutcome <- lapply(ps, switchOutcome, populationCm = populationCm)
      cases <- do.call(rbind, lapply(psSwitchedOutcome, getCounts, timePoint = timePoint))
      colnames(cases) <- c("comparator", "treatment")
      cases <- as.data.frame(cases)
      cases$riskStratum <- paste0("Q", 1:riskStrata)

      if(psMethod == "matchOnPs"){

        matchedPop <- lapply(psSwitchedOutcome, CohortMethod::matchOnPs)
        models <- lapply(matchedPop,
                         CohortMethod::fitOutcomeModel, stratified = TRUE, modelType = "cox")
        arr <- do.call(rbind, lapply(matchedPop, absoluteRiskReduction, timePoint = timePoint, psMethod = psMethod))
        colnames(arr) <- c("ARR", "lower", "upper")
        arr <- as.data.frame(arr)
        arr$riskStratum <- paste0("Q", 1:riskStrata)
        rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
        colnames(rrr) <- c("HR", "lower", "upper")
        rrr <- as.data.frame(rrr)
        rrr$riskStratum <- paste0("Q", 1:riskStrata)

      }
      else if(psMethod == "stratifyByPs"){

        stratifiedPop <- lapply(psSwitchedOutcome, CohortMethod::stratifyByPs)
        models <- lapply(stratifiedPop,
                         CohortMethod::fitOutcomeModel, stratified = TRUE, modelType = "cox")
        arr <- do.call(rbind, lapply(stratifiedPop, absoluteRiskReduction, timePoint = timePoint, psMethod = "stratifyByPS"))
        colnames(arr) <- c("ARR", "lower", "upper")
        arr <- as.data.frame(arr)
        arr$riskStratum <- paste0("Q", 1:riskStrata)
        rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
        colnames(rrr) <- c("HR", "lower", "upper")
        rrr <- as.data.frame(rrr)
        rrr$riskStratum <- paste0("Q", 1:riskStrata)

      }
      else if(psMethod == "inversePtWeighted"){

        psSwitchedOutcome <- lapply(psSwitchedOutcome,
                                    createIPW,
                                    weightsType = weightsType,
                                    useStabilizedWeights = useStabilizedWeights,
                                    truncationLevels = truncationLevels)
        models <- lapply(psSwitchedOutcome, outcomeModelWeighted, calculateWeights = FALSE)
        arr <- do.call(rbind, lapply(psSwitchedOutcome, absoluteRiskReduction, timePoint = timePoint, psMethod = "inversePtWeighted"))
        colnames(arr) <- c("ARR", "lower", "upper")
        arr <- as.data.frame(arr)
        arr$riskStratum <- paste0("Q", 1:riskStrata)
        rrr <- do.call(rbind, lapply(models, relativeRiskReduction))
        colnames(rrr) <- c("HR", "lower", "upper")
        rrr <- as.data.frame(rrr)
        rrr$riskStratum <- paste0("Q", 1:riskStrata)
      }

      saveDir <- paste(analysisPath, "Estimation", outcomeId, comparisonOutcomes[j], sep = "/")
      if(!dir.exists(saveDir)){dir.create(saveDir, recursive = T)}
      saveRDS(rrr, file = file.path(saveDir, 'relativeRiskReduction.rds'))
      saveRDS(arr, file = file.path(saveDir, 'absoluteRiskReduction.rds'))
      saveRDS(models, file = file.path(saveDir, 'models.rds'))
      saveRDS(cases, file = file.path(saveDir, 'cases.rds'))

    }
  }
  return(NULL)
}






getCounts <- function(ps, timePoint){

  ps <- as.data.frame(ps)

  ps$event <- ifelse(is.na(ps$daysToEvent), 0, 1)
  ps$S <- survival::Surv(ps$survivalTime, ps$event)

  kaplanMeier <-  survival::survfit(S ~ treatment, data = ps)

  summaryKM <- summary(kaplanMeier, times = timePoint)
  1 - summaryKM$surv


}




getStandadrdError <- function(summaryKmList){

  sqrt(sum(summaryKmList$std.err^2))
}




getAbsoluteDifference <- function(summaryKMList){
  diff(summaryKMList$surv)
}
