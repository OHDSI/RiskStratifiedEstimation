#' Absolute risk reduction
#'
#' Calculates absolute risk reduction based on the Kaplan-Meier estimates within risk strata
#'
#' @param population         The study population generated by \code{\link[CohortMethod]{matchOnPs}} when using propensity score
#'                           matching or by \code{\link[CohortMethod]{stratifyByPs}} when stratifying on the propensity score. In
#'                           case of inverse probability of treatment weighting approach, it is a datframe with a \code{weights}
#'                           column.
#' @param timePoint          The time at which the absolute risk difference is estimated
#' @param psMethod           Can be one of "matchOnPs", "stratifyByPs" or "inversePtWeighted".
#'
#' @return                   A dataframe with the absolute risk-stratum specific absolute risk difference estimates, along
#'                           with 95 percent confidence interval.
#'
#' @export

absoluteRiskReduction <- function(population,
                                  timePoint,
                                  psMethod){

  population <- as.data.frame(population)
  population$event <- ifelse(is.na(population$daysToEvent), 0, 1)
  population$S <- survival::Surv(population$survivalTime, population$event)

  kaplanMeier <-  survival::survfit(S ~ treatment, data = population)

  if(psMethod == "matchOnPs"){

    summaryKM <- summary(kaplanMeier, times = timePoint)
    standardError <- sqrt(sum(summaryKM$std.err^2))
    arr <- diff(summaryKM$surv)
    res <- c(arr, arr - 1.96*standardError, arr + 1.96*standardError)

  }
  else if(psMethod == "stratifyByPS"){

    kaplanMeier <- list()
    kk <- sort(unique(population$stratumId))
    for(i in kk){
      kaplanMeier[[i]] <- survival::survfit(S ~ treatment, data = subset(population, stratumId == i))
    }

    summaryKMList <- lapply(kaplanMeier, summary, times = timePoint)
    arrList <- lapply(summaryKMList, getAbsoluteDifference)

    arr <- mean(unlist(arrList))
    standardErrors <- lapply(summaryKMList, getStandadrdError)
    pooledStandardError <- sqrt(sum(unlist(standardErrors)^2)/25)
    res <- c(arr, arr - 1.96*pooledStandardError, arr + 1.96*pooledStandardError)

  }

  else if(psMethod == "inversePtWeighted"){

    kaplanMeier <-  survival::survfit(S ~ treatment, data = population, weights = weights)
    summaryKM <- summary(kaplanMeier, times = timePoint)
    standardError <- sqrt(sum(summaryKM$std.err^2))
    arr <- diff(summaryKM$surv)
    res <- c(arr, arr - 1.96*standardError, arr + 1.96*standardError)

  }

  return(res)

}




#' Relative risk reduction
#'
#' Calculates hazard ratios within risk strata.
#' @param model    The model that was used to fit a cox regression model to the data.
#'
#' @return         A dataframe with hazard ratios for treatment effect across risk strata along with 95 percent confidence intervals
#'
#' @export

relativeRiskReduction <- function(model){

  if(class(model) == "outcomeModel")
    return(exp(model$outcomeModelTreatmentEstimate[1:3]))
  else
    return(summary(model)$conf.int[c(1, 3:4)])

}




#' Fits a weighted cox regression model
#'
#' Fits a weighted cox regression model using an inverse probability of treatment weighting approach
#'
#' @param ps                          A dataframe wiht propensity scores as generated from \code{\link[CohortMethod]{createPs}}.
#' @param calculateWeights            Should weights be calculated?
#' @param weightsType                 The type of weights for the balancing of covariates. Should be either 'ATE' or 'ATT'
#' @param useStabilizedWeights        Should stabilized weights be used?
#' @param truncationLevels            The level of truncation expressed in percentiles of the propensity score.
#'
#' @return                            A weighted cox regression model.
#'
#' @export

outcomeModelWeighted <- function(ps,
                                 calculateWeights = TRUE,
                                 weightsType = 'ATE',
                                 useStabilizedWeights = TRUE,
                                 truncationLevels){

  if(calculateWeights)
    ps <- createIPW(ps,
                    weightsType = weightsType,
                    useStabilizedWeights = useStabilizedWeights,
                    truncationLevels = truncationLevels)



  ps$outcomeCount <- ifelse(ps$outcomeCount != 0, 1, 0)
  model <- survival::coxph(survival::Surv(survivalTime, outcomeCount) ~ treatment,
                           data = ps,
                           weights = ps$weights, robust = TRUE)
  return(model)

}



#' Creates Inverse Probability Weights
#'
#' Calcuates inverse probability weights based on the propensity score
#'
#' @param ps A propensity score data frame as created from \code{\link[CohortMethod]{createPs}}
#' @param weightsType The type of the weights to be used. Allowed options are 'ATE' for average treatment effect and 'ATT' for average treatment effect on the treated weights
#' @param useStabilizedWeights Should stabilized weights be used?
#' @param truncationLevels The level of truncation expressed in percentiles of the propensity score.
#'
#' @return The ps data frame provided as input along with a weights column
#'
#' @export

createIPW <- function(ps,
                      weightsType = 'ATE',
                      useStabilizedWeights = TRUE,
                      truncationLevels = c(.01, .99)){

  if(weightsType == 'ATE')
    ps$weights <- ps$treatment / ps$propensityScore + (1 - ps$treatment) / (1 - ps$propensityScore)
  else
    ps$weights <- ps$treatment + ps$propensityScore*(1 - ps$treatment) / (1 - ps$propensityScore)

  if(useStabilizedWeights){
    ps$stability <- mean(ps$treatment)
    ps$weights <- ps$treatment*ps$weights*ps$stability +
      (1 - ps$treatment)*ps$weights*(1 - ps$stability)
    ps <- dplyr::select(ps, -stability)
  }

  ps <-  dplyr::mutate(ps, weights = pmin(pmax(weights, quantile(weights, truncationLevels[1])),
                                          quantile(weights, truncationLevels[2])))


  return(ps)

}



#' Calculates the weighted Kaplan-Meier estimates
#'
#' Calculates the weighted Kaplan-Meier estimates.
#'
#' @param ps A data frame including the propensity scores as generated from \code{\link[CohortMethod]{createPs}}
#' @param calculateWeights Whether to calculate the weights using \code{\link[RiskStratifiedEstimation]{createIPW}}
#' @param weightsType The type of the weights to be used. Allowed options are 'ATE' for average treatment effect and 'ATT' for average treatment effect on the treated weights
#' @param useStabilizedWeights Should stabilized weights be used?
#' @param truncationLevels The level of truncation expressed in percentiles of the propensity score.
#'
#' @return A data frame with the Kaplan-Meier estimates
#'
#' @references Xie J, Liu C. Adjusted Kaplan-Meier estimator and log-rank test with inverse probability of treatment weighting for survival data. Statistics in Medicine 2005; 2:3089â€“3110.
#'
#' @export

weightedKM <- function(ps,
                       calculateWeights = TRUE,
                       weightsType = 'ATE',
                       useStabilizedWeights = TRUE,
                       truncationLevels){

  if(calculateWeights)
    ps <- createIPW(ps,
                    weightsType = weightsType,
                    useStabilizedWeights = useStabilizedWeights,
                    truncationLevels = truncationLevels)

  ps <- subset(ps, select = c('subjectId', 'treatment', 'outcomeCount', 'daysToEvent', 'survivalTime', 'weights'))
  ps$failure <- ifelse(is.na(ps$daysToEvent), 0, 1)
  ps$outcomeCount <- ifelse(ps$outcomeCount>0, 1, 0)

  psTreatment <- subset(ps, treatment == 1)
  psTreatment <- dplyr::arrange(psTreatment, survivalTime)
  p1 <- length(psTreatment$weights)

  psComparator <- subset(ps, treatment == 0)
  psComparator <- dplyr::arrange(psComparator, survivalTime)
  p0 <- length(psComparator$weights)
  s <- 1
  S <- 1
  V <- 0
  dataTreatment <- data.frame(time = numeric(),
                              S = numeric(),
                              varS = numeric(),
                              lower = numeric(),
                              upper = numeric(),
                              eventTime = numeric())

  for(i in unique(psTreatment$survivalTime)){

    j <- which(psTreatment$survivalTime == i)
    v <- sum(psTreatment$failure[j]*psTreatment$weights[j])
    eventTime <- ifelse(v>0, 1, 0)
    y <- tail(cumsum(psTreatment$weights[min(j):p1]), n = 1)
    M <- y^2/tail(cumsum(psTreatment$weights[min(j):p1]^2), n = 1)
    s_j <- 1 - v/y
    V <- V + (1 - s_j)/M/s_j
    S <- S*s_j
    varS <- S^2*V
    lower = exp(-exp(log(-log(S)) - 1.96*sqrt(V)/log(S)))
    upper = exp(-exp(log(-log(S)) + 1.96*sqrt(V)/log(S)))
    dataTreatment[s, ] <- c(i, S, varS, lower, upper, eventTime)
    s <- s + 1

  }

  s <- 1
  S <- 1
  V <- 0
  dataComparator <- data.frame(time = numeric(),
                               S = numeric(),
                               varS = numeric(),
                               lower = numeric(),
                               upper = numeric(),
                               eventTime = numeric())

  for(i in unique(psComparator$survivalTime)){

    j <- which(psComparator$survivalTime == i)
    v <- sum(psComparator$failure[j]*psComparator$weights[j])
    eventTime <- ifelse(v>0, 1, 0)
    y <- tail(cumsum(psComparator$weights[min(j):p0]), n = 1)
    M <- y^2/tail(cumsum(psComparator$weights[min(j):p0]^2), n = 1)
    s_j <- 1 - v/y
    V <- V + (1 - s_j)/M/s_j
    S <- S*s_j
    varS <- S^2*V
    lower = exp(-exp(log(-log(S)) - 1.96*sqrt(V)/log(S)))
    upper = exp(-exp(log(-log(S)) + 1.96*sqrt(V)/log(S)))
    dataComparator[s, ] <-c(i, S, varS, lower, upper, eventTime)
    s <- s + 1

  }

  dataCombined <- dplyr::bind_rows(list(treatment=dataTreatment,
                                        comparator = dataComparator),
                                   .id = 'cohort')


  return(dataCombined)
}



#' Calculate stratified Kaplan-Meier estimates
#'
#' @param population                The population of interest stratified using the  \code{\link[CohortMethod]{stratifyByPs}}
#' @param timePoint                 The point in time for which the absolute risk difference is required
#'
#' @return                          A vector of the absolute risk difference along with the lowest and highest limits of the
#'                                  the 95 percent confidence interval
#'
stratifiedKaplanMeier <- function(population, timePoint){
  kaplanMeier <- list()
  for(i in unique(population$stratumId)){
    kaplanMeier[[i]] <- survival::survfit(S ~ treatment, data = subset(population, stratumId == i))
  }

  summaryKMList <- lapply(kaplanMeier, summary, times = timePoint)
  arrList <- lapply(summaryKMList, getAbsoluteDifference)

  arr <- mean(unlist(arrList))
  standardErrors <- lapply(summaryKMList, getStandadrdError)
  pooledStandardError <- sqrt(sum(unlist(standardErrors)^2)/25)
  return(c(arr, arr - 1.96*pooledStandardError, arr + 1.96*pooledStandardError))

}





getCounts <- function(ps, timePoint){

  ps <- as.data.frame(ps)

  ps$event <- ifelse(is.na(ps$daysToEvent), 0, 1)
  ps$S <- survival::Surv(ps$survivalTime, ps$event)

  kaplanMeier <-  survival::survfit(S ~ treatment, data = ps)

  summaryKM <- summary(kaplanMeier, times = timePoint)
  1 - summaryKM$surv


}




getStandadrdError <- function(summaryKmList){

  sqrt(sum(summaryKmList$std.err^2))
}




getAbsoluteDifference <- function(summaryKMList){
  diff(summaryKMList$surv)
}
